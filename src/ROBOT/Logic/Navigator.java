package ROBOT.Logic;

import ROBOT.Logger.MyLogger;
import ROBOT.Logic.Driver.Commands;
import ROBOT.Logic.Interfaces.CarSensorInput.Sensor;
import ROBOT.Structure.SensorMap;

import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Map.Entry;

/**
 * A Class that evaluates Sensor Values and tells the driver what Command to execute
 * Here are the rules clearly defined
 */
public class Navigator {

    private final int howMany = 4; // value should be even
    private LinkedHashMap<Long, SensorMap> readouts = new LinkedHashMap<Long, SensorMap>() {

        /** Generated by Intellij IDE */
        private static final long serialVersionUID = -8310411362471275532L;

        @Override
        protected boolean removeEldestEntry(final Entry<Long, SensorMap> eldest) {
            return size() > howMany;
        }
    };
    private boolean approachingObstacle = false;
    private boolean approachingWall = false;
    private boolean obstacleImminent = false;
    private boolean obstacleLeft = false;
    private boolean obstacleRight = false;
    private boolean obstacleBehind = false;
    private Side prefer = Side.LEFT;
    private long lockedTill = 0;

    public void update(SensorMap map) {
        long time = new Date().getTime();
        readouts.put(time, map);
        calc();
    }

    private void calc() {
        Double firstForward = 0d;
        Double lastForward = 0d;
        Double leftAvg = 0d;
        Double rightAvg = 0d;
        Double revAvg = 0d;

        int halfAsMany = (int) (howMany * 0.5);

        int i = 0;
        for (Entry<Long, SensorMap> entries : readouts.entrySet()) {
            SensorMap map = entries.getValue();
            Double forward = map.get(Sensor.F);

            if (halfAsMany > i++) {
                firstForward += forward.isInfinite() ? 255 : forward;
            } else {
                Double left = map.get(Sensor.L);
                Double right = map.get(Sensor.R);
                Double reverse = map.get(Sensor.B);

                lastForward += forward;
                leftAvg += left.isInfinite() ? 255 : left;
                rightAvg += right.isInfinite() ? 255 : right;
                revAvg += reverse.isInfinite() ? 255 : reverse;
            }
        }

        firstForward /= halfAsMany;
        lastForward /= halfAsMany;
        leftAvg /= halfAsMany;
        rightAvg /= halfAsMany;
        revAvg /= halfAsMany;

        obstacleImminent = lastForward < 40;
        approachingObstacle = (firstForward - lastForward) > 20 || lastForward < 100;
        approachingWall = firstForward < 100 && lastForward.isInfinite();

        obstacleLeft = leftAvg < 30;
        obstacleRight = rightAvg < 30;
        obstacleBehind = revAvg < 30;

        prefer = leftAvg > rightAvg ? Side.LEFT : Side.RIGHT;

        MyLogger.debug("approaching-obstacle: " + approachingObstacle + ", appr-wall: " + approachingWall +
                ", ob-l: " + obstacleLeft + ", ob-r: " + obstacleRight + ", ob-b: " + obstacleBehind + ", pref: " +
                prefer.name());
        MyLogger.debug("reverse: " + revAvg);
    }

    public Commands navigate() {
        if (!obstacleImminent && !isLocked()) {

            if (!approachingObstacle && !approachingWall)
                return Commands.FORWARD;

            if (!obstacleLeft || !obstacleRight)
                return prefer == Side.LEFT ? Commands.LEFT : Commands.RIGHT;

        }

        if (!obstacleBehind) {

            if (!isLocked())
                lock(500);

            if (!obstacleLeft || !obstacleRight)
                return prefer == Side.LEFT ? Commands.REV_LEFT : Commands.REV_RIGHT;


            return Commands.REVERSE;
        }
        unlock();
        return Commands.HALT;
    }

    public Commands navigate2(SensorMap map) {
        //FORWARD
        if (map.get(Sensor.FL) > 10 && map.get(Sensor.FR) > 10 && map.get(Sensor.BL) > 10 && map.get(Sensor.BR) > 10) {
            return Commands.FORWARD;
        }
        //left
        if (map.get(Sensor.FL) > 10 && map.get(Sensor.FR) < 10 && map.get(Sensor.BL) > 10 && map.get(Sensor.BR) > 10) {
            return Commands.LEFT;
        }
        //right
        if (map.get(Sensor.FL) < 10 && map.get(Sensor.FR) < 10 && map.get(Sensor.BL) > 10 && map.get(Sensor.BR) > 10) {
            return Commands.RIGHT;
        }
        //reverse
        if (map.get(Sensor.FL) < 10 && map.get(Sensor.FR) < 10 && map.get(Sensor.BL) > 10 && map.get(Sensor.BR) > 10) {
            return Commands.REVERSE;
        }
        //revLeft
        if (map.get(Sensor.FL) < 10 && map.get(Sensor.FR) < 10 && map.get(Sensor.BL) > 10 && map.get(Sensor.BR) < 10) {
            return Commands.REV_LEFT;
        }//revRight
        if (map.get(Sensor.FL) < 10 && map.get(Sensor.FR) < 10 && map.get(Sensor.BL) < 10 && map.get(Sensor.BR) > 10) {
            return Commands.REV_RIGHT;
        }
        return Commands.HALT;
    }

    void lock(int ms) {
        lockedTill = new Date().getTime() + ms;
    }

    void unlock() {
        lockedTill = 0;
    }

    boolean isLocked() {
        return lockedTill > new Date().getTime();
    }

    enum Side {LEFT, RIGHT}
}
